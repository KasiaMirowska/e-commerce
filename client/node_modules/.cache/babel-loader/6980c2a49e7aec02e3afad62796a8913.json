{"ast":null,"code":"import _regeneratorRuntime from\"/Users/kamirska/UDEMYlearning/e-commerce/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Users/kamirska/UDEMYlearning/e-commerce/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/kamirska/UDEMYlearning/e-commerce/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import firebase from'firebase/app';import'firebase/firestore';//for database\nimport'firebase/auth';//for authentication\nvar config={apiKey:\"AIzaSyAvZb8PsjokOEf4AC16V0613SHcH7ESYeI\",authDomain:\"crown-db-3ccd2.firebaseapp.com\",databaseURL:\"https://crown-db-3ccd2.firebaseio.com\",projectId:\"crown-db-3ccd2\",storageBucket:\"crown-db-3ccd2.appspot.com\",messagingSenderId:\"506711171270\",appId:\"1:506711171270:web:b0f9c788f57944529637c7\"// measurementId: \"G-6SS2MF5K16\"\n};//saving a user into db passing userAuth object that we receive when googleSignIn...we ALWAYS recieve an object back but it might be empty\nexport var createUserProfileDocument=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(userAuth,additionalData){var userRef,snapshot,displayName,email,createdAt,userRefSet;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(userAuth){_context.next=3;break;}console.log('does not exist');return _context.abrupt(\"return\");case 3://if does exist then query the db\nuserRef=firestore.doc(\"users/\".concat(userAuth.uid));_context.next=6;return userRef.get();case 6:snapshot=_context.sent;if(snapshot.exists){_context.next=19;break;}displayName=userAuth.displayName,email=userAuth.email;createdAt=new Date();_context.prev=10;userRefSet=_objectSpread({//another firestore method for creating a user\ndisplayName:displayName,email:email,createdAt:createdAt},additionalData);_context.next=14;return userRef.set(userRefSet);case 14:_context.next=19;break;case 16:_context.prev=16;_context.t0=_context[\"catch\"](10);console.log('error creating a user',_context.t0.message);case 19:return _context.abrupt(\"return\",userRef);case 20:case\"end\":return _context.stop();}}},_callee,null,[[10,16]]);}));return function createUserProfileDocument(_x,_x2){return _ref.apply(this,arguments);};}();export var addCollectionAndDocuments=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(collectionName,objectsToAdd){var collectionRef,batch;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:collectionRef=firestore.collection(collectionName);//we're calling for the collection object which firebase returns even if it's empty.\nconsole.log(collectionRef,'COLLECTIONREFFFFFFFFFFFF',objectsToAdd,\"OBJECT?????\");//now we will start to populate the collection with objects/items one at the time as doc with multiple calls gathered in one batch\nbatch=firestore.batch();objectsToAdd.forEach(function(obj){var newDocRef=collectionRef.doc();//method to make firestore assign an id to each genereated object in the db collection, for each item\nbatch.set(newDocRef,obj);//now we're assiginig the value of our object item to each doc created in db in order to save it. batch method will group these calls into a queues for us authomaticly\n});//now we need to commit the calls to db\n_context2.next=6;return batch.commit();case 6:return _context2.abrupt(\"return\",_context2.sent);case 7:case\"end\":return _context2.stop();}}},_callee2);}));return function addCollectionAndDocuments(_x3,_x4){return _ref2.apply(this,arguments);};}();export var convertCollectionSnapshotToMap=function convertCollectionSnapshotToMap(collections){var transformedCollections=collections.docs.map(function(doc){var _doc$data=doc.data(),title=_doc$data.title,items=_doc$data.items;//this method gets the actual value of the documentRef \nreturn{routeName:encodeURI(title.toLowerCase()),id:doc.id,title:title,items:items};});return transformedCollections.reduce(function(accumulator,collection){accumulator[collection.title.toLowerCase()]=collection;return accumulator;},{});};firebase.initializeApp(config);//configuration neccesary for google auth\nexport var auth=firebase.auth();export var firestore=firebase.firestore();export var googleProvider=new firebase.auth.GoogleAuthProvider();//from firebase library for google auth\ngoogleProvider.setCustomParameters({prompt:'select_account'});//makes a pop up with google acc to choose from, provider is a class\nexport default firebase;","map":{"version":3,"sources":["/Users/kamirska/UDEMYlearning/e-commerce/src/firebase/firebase.util.js"],"names":["firebase","config","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","createUserProfileDocument","userAuth","additionalData","console","log","userRef","firestore","doc","uid","get","snapshot","exists","displayName","email","createdAt","Date","userRefSet","set","message","addCollectionAndDocuments","collectionName","objectsToAdd","collectionRef","collection","batch","forEach","obj","newDocRef","commit","convertCollectionSnapshotToMap","collections","transformedCollections","docs","map","data","title","items","routeName","encodeURI","toLowerCase","id","reduce","accumulator","initializeApp","auth","googleProvider","GoogleAuthProvider","setCustomParameters","prompt"],"mappings":"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","sourcesContent":["import firebase from 'firebase/app';\nimport 'firebase/firestore'; //for database\nimport 'firebase/auth'; //for authentication\n\n\nconst config = {\n    apiKey: \"AIzaSyAvZb8PsjokOEf4AC16V0613SHcH7ESYeI\",\n    authDomain: \"crown-db-3ccd2.firebaseapp.com\",\n    databaseURL: \"https://crown-db-3ccd2.firebaseio.com\",\n    projectId: \"crown-db-3ccd2\",\n    storageBucket: \"crown-db-3ccd2.appspot.com\",\n    messagingSenderId: \"506711171270\",\n    appId: \"1:506711171270:web:b0f9c788f57944529637c7\",\n    // measurementId: \"G-6SS2MF5K16\"\n  };\n  //saving a user into db passing userAuth object that we receive when googleSignIn...we ALWAYS recieve an object back but it might be empty\n  export const createUserProfileDocument = async ( userAuth, additionalData) => {\n    if(!userAuth) {\n       console.log('does not exist')\n       return;\n    }\n    //if does exist then query the db\n    const userRef = firestore.doc(`users/${userAuth.uid}`);\n    const snapshot = await userRef.get()\n    \n    //or create a new user\n    if(!snapshot.exists) {\n        const {displayName, email} = userAuth;\n        const createdAt = new Date();\n       \n        try {\n            const userRefSet = { //another firestore method for creating a user\n                displayName,\n                email,\n                createdAt,\n                ...additionalData\n            };\n            \n            await userRef.set(userRefSet)\n\n        }catch (err) {\n            console.log('error creating a user', err.message)\n        }\n    }\n    return userRef;\n  }\n\n  export const addCollectionAndDocuments = async(collectionName, objectsToAdd) => {\n    const collectionRef= firestore.collection(collectionName) //we're calling for the collection object which firebase returns even if it's empty.\n    console.log(collectionRef, 'COLLECTIONREFFFFFFFFFFFF', objectsToAdd, \"OBJECT?????\") //now we will start to populate the collection with objects/items one at the time as doc with multiple calls gathered in one batch\n    const batch = firestore.batch();\n    objectsToAdd.forEach(obj => {\n        const newDocRef = collectionRef.doc()//method to make firestore assign an id to each genereated object in the db collection, for each item\n        batch.set(newDocRef, obj) //now we're assiginig the value of our object item to each doc created in db in order to save it. batch method will group these calls into a queues for us authomaticly\n    })\n     //now we need to commit the calls to db\n    return await batch.commit()\n  }\n\n  export const convertCollectionSnapshotToMap = (collections) => {\n      const transformedCollections = collections.docs.map(doc => {\n          const { title, items } = doc.data() //this method gets the actual value of the documentRef \n          return {\n              routeName: encodeURI(title.toLowerCase()),\n              id: doc.id,\n              title,\n              items\n          }\n      })\n      \n      return transformedCollections.reduce((accumulator, collection) => {\n          accumulator[collection.title.toLowerCase()] = collection;\n          return accumulator;\n      }, {})\n  }\n\n  firebase.initializeApp(config);\n  //configuration neccesary for google auth\n\n  export const auth = firebase.auth();\n  export const firestore = firebase.firestore();\n\n  export const googleProvider = new firebase.auth.GoogleAuthProvider(); //from firebase library for google auth\n  googleProvider.setCustomParameters({ prompt: 'select_account' }); //makes a pop up with google acc to choose from, provider is a class\n  \n  export default firebase;\n\n\n"]},"metadata":{},"sourceType":"module"}